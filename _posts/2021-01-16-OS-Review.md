---
layout:    post   				    # 使用的布局（不需要改）
title:     「Operating System」Course Review # 标题 
subtitle:  Collection of key points in Operating System #副标
date:      2021-01-16 				# 时间
author:    Culaccino					# 作者
header-img: img/upd_img10.png       #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 专业课
- OS

---

操作系统（Operating System）是计算机软件中最基础、最核心的部分，是计算机用户与计算机硬件之间的中介程序，起到了承上启下的作用。在做关于基础软件的调查时，我非常认同这句话：**「操作系统国产化是软件自主可控的基本保证，而基础软件国产化的发展历程并未以全新底层硬件生态体系构建作为出发点，使得国产化效果大打折扣」**，这也体现了操作系统在计算机系统、计算机生态中的地位。

之所以把操作系统的内容全部放在一起发出来，是因为对于偏物理底层的领域，我个人比较喜欢以自己掌握的系统学习的方法来整理。本学期中课堂时间其实没怎么听课，倒是做实验和设计课堂pbl算法时，有目的性地高效过了一遍书，真正学到的东西可能比理论课要多得多……但即便是这样，其实现阶段我也只停留在知道「会用到的数据结构」、「完成某个功能要涉及到的数据元素」以及偏整体性的「整个系统的设计思想」，就仿佛软件开发者设计好了总体设计后、才刚踏进详细设计的半个门槛的水平。

这篇总结只是一些重要知识点的合集，真正要将OS的设计精髓掌握于心还是要靠编程做题。说实话，我个人其实是很希望能够将OS和计组原理的知识结合起来，然后顺藤摸瓜，把各种机理的实现落实到比特位的设计上的（可能有些夸张了233）。目前的想法是寒假的时候去好好学一下最近很热门的苹果新芯片M1，以一个科班出身的学生的角度，学一些新东西，并且有空的时候再多去读读linux的源码。

# 1. 操作系统概论

## 1.1 概念

**计算机系统(自下而上)**

- 硬件
  - 中央处理器(CPU:运算器+控制器)、内存、外存、其他外部设备
- 软件
  - 系统软件(操作系统，语言处理系统)
  - 支撑软件(数据库管理系统，常用的服务程序)
  - 应用软件

#### 操作系统的概念

- 用户观点：OS是用户与计算机硬件系统之间的接口。
- 资源管理观点：OS是系统资源的管理者，是目前关于OS描述的主要观点。
- 虚拟机观点：通常把覆盖了软件的机器称为扩充机器或虚拟机。

**综上可对OS定义：OS是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。**



## 1.2 发展分类

- 手工操作阶段
- 批处理操作系统
  - 单道批处理
  - **多道批处理**：资源利用率高，系统吞吐量大；但作业的平均周转时间长，无交互能力
- 分时操作系统：时间片轮换；多路性、独立性、及时性、**交互性**。
- 实时操作系统：实时任务：周期性(周期性/非周期性)，截止始/末时间(硬/软)；**及时性**和可靠性
- 微机操作系统
- 网络操作系统
- 分布式操作系统
- 嵌入式操作系统



## 1.3 特征&功能

**特征**

1. **并发性**：在同一时间**间隔**（而非时刻）内同时发生多个事件。程序不能并行，但实体进程可以。

2. **共享性**

   互斥共享：在一段时间内只能由一个程序使用。eg：打印机、绘图仪

   同时共享：系统资源允许同一段时间内被多个程序同时访问。

   **并发性和共享性为OS的两个基本特征，他们互为存在条件。**

3. **虚拟性**

   将物理实体映射为逻辑对应物，让用户感觉有多个实体可供使用，但都对应了同一块物理实体。

4. **异步性**

   即不确定性，进程运行需要由程序执行时的现场所决定。

   

**功能**（从资源管理的观点出发）

1. **处理器管理**：调度处理器
2. **存储器管理**：管理内存资源，根据内存空间的使用情况和用户要求为程序分配内存空间，并在合适时机回收
3. **设备管理**：管理除处理器、内存外的所有设备，根据用户请求和设备的状态进行调度分配
4. **文件管理**：管理以文件形式存放在外存汇总的程序和数据
5. **提供用户接口**：为用户提供「命令接口、程序接口、图形接口」



# 2. OS硬件基础

## 2.3 中断和时钟

#### 中断

**作用**：①提高计算机系统效率  ②维持系统可靠正常工作  ③满足实时处理要求  ④提供故障现场处理手段

**分类**：

- 中断（异步）：可屏蔽中断、非屏蔽中断（按是否程序可控分）
- 异常（同步）：处理器探测异常（故障、陷阱、异常中止）、编程异常

**处理过程**：处理器执行指令时，根据操作码是否是访管指令，来确定是否有自愿性中断事件发生。若有，则通知中断装置；对于强迫性中断，中断装置只要检查中断寄存器的内容，若非“0”，表示有中断事件发生。

#### 系统调用

系统调用在用户程序与硬件设备之间添加了一个中间层，使得①用户能够得到对计算机硬件的抽象接口 ②内核可以根据权限命令判断正确性，提高系统稳定性安全性 ③应用程序的可移植性提高。

**处理过程**：

1. 应用程序在用户态下执行访管指令INT 0x80，产生一个编程异常，系统进行中断处理。
2. 再使用128号查找中段描述符表，得到该异常的中断处理程序（system_call()）的入口地址。
3. 保存CPU现场信息，执行system_call()函数，该过程检查系统调用号，并告诉内核进程请求哪种服务。
4. 然后，它查看系统调用表（sys_call_table）找到所调用的内核函数入口地址，调用函数，等返回后做一些系统检查，最后返回到进程。



# 3. 进程管理

## 3.1 进程的引入

**必要性**：支持程序能够并发运行、控制协调程序运行对软硬件资源的共享与竞争。

**功能**：进程控制、进程互斥与同步、进程通信、调度

## 3.2 进程的概念

简单来说，进程=（有需要的一个或一组）程序（即静态方法）+ 实际运行信息（PCB：状态信息、进程创建得到的属性、对资源的占用情况、调度信息等）。

**特点**：动态性（静态方法+动态信息）、并发性、独立性、异步性。

**状态**

- 创建状态：正在被创建。①创建完成->就绪状态
- 就绪状态：只要获得处理器即可立即执行。①进程调度 -> 运行状态
- 运行状态：正在执行。①时间片到 -> 就绪状态 ②等待某事件发生I/O -> 阻塞状态
- 终止状态：正常结束或被异常中止。
- 阻塞状态：等待某事件发生。①所等待的事件完成->就绪状态

## 3.3 进程控制

- 进程创建
  - 典型事件：作业调度(磁盘->内存)、用户登录(shell)、提供特定服务、应用请求
  - 流程
    - 申请尚未被使用的pid和一个空白pcb
    - 为新进程分配必要资源
    - 初始化新进程的pcb
    - 将新进程状态置为就绪状态，插入就绪队列，等待CPU调度
- 进程撤销
  - 典型事件：正常结束、异常终止、因外界干预而撤销
  - 流程
    - 根据pid从系统的pcb集合中找到该进程的pcb，停止其运行，并将系统调度标志置为“真”
    - 撤销其子进程，或指定一个临时的父进程（如init初始进程）
    - 回收该进程的所有系统资源
    - 将该进程的pcb从系统pcb集合中移除
- 进程阻塞与唤醒
  - 典型事件：请求资源失败、等待某种操作完成、前驱进程尚未完成、进程无新工作可做
  - 阻塞流程
    - 立即停止进程运行，保存其CPU现场信息到pcb中
    - 将pcb中的进程状态改为“阻塞”
    - 将进程插入阻塞队列
    - 通过进程调度程序，将CPU分配给另一就绪进程运行
  - 唤醒流程
    - 查找该事件的阻塞队列，根据情况唤醒相关进程
    - 被唤醒的进程从阻塞队列中移出，将其状态改为“就绪“
    - 插入就绪队列等待CPU调度

## 3.4 进程同步

#### 进程异步

- **临界资源**：一次只允许一个进程使用
- **临界区**：进程中访问临界资源的代码段
- **原则**：空闲让进、忙则等待、有限等待（动态优先级作用）、让权等待（进程权限问题）

#### 进程同步

- 进程间需要按照一定顺序执行，互相配合、交换一定的信息，以完成共同任务

#### ※同步机制

硬件方法、软件方法、锁机制、**信号量机制**等

**记录型信号量**：wait类似于Posix中的sys_wait，signal类似于Posix中的sys_post。信号量S有对应的阻塞队列，用于存放调度过程中阻塞状态的进程。在利用记录型信号量设计算法时，先分析解决任务的整体流程，思考哪一部分需要完成”互斥/同步“，再根据此来设置互斥/同步间所需的信号量。（其实如果OS实验啃得透的话这是非常容易的）

![](https://tva1.sinaimg.cn/large/008eGmZEly1gmmjeu1ry9j32kn0u0qhr.jpg)

#### Linux同步机制

①原子操作 ②自旋锁 ③读-写自旋锁 ④内核信号量 ⑤读-写信号量

**⑥IPC信号量（System V信号量） ⑦Posix信号量（有名/无名）**:编程时常用，具体回顾实验



## 3.5 进程调度

作业调度（后备队列中将作业调入内存，高级调度、中级调度）+进程调度（从就绪队列中选择进程获得处理器，低级调度、中级调度），进程调度为重点。

#### 重要概念

- 进程调度的方式
  - 非抢占方式：等一个进程完成后才会执行下一个
  - 抢占方式：可以按照某种原则（如优先级等）强制性剥夺该进程的CPU而分配给其他进程
- 算法设计考虑点
  - 系统设计目标：批处理/交互式/实时系统
  - 调度公平性：减少饥饿现象
  - 资源的均衡利用：提高系统的资源利用率
  - 合理的系统开销：调度也不宜过于频繁
- 评价指标
  - CPU利用率
  - 系统吞吐量
  - 周转时间=完成时间-提交时间
  - 带权周转时间=周转时间/要求执行时间
  - 响应时间（对第一个请求）开始处理的时间-提交时间
  - 对截止时间的保证：能否在规定截止时间完成实时任务

#### 进程调度算法

- 先来先服务（FCFS）：先进先出，非抢占式。
- 短作业优先调度（SJF）：从后备队列汇总选出若干个短作业调入内存，从就绪队列中选出下一次最短作业。非抢占、抢占都可。
- 高响应比优先调度（HRRF）：响应比∝等待时间/要求服务时间，非抢占式，在每次处理完一个任务后更新所有进程的响应比。
- 优先级调度：根据进程的优先级（静态或动态）选择。非抢占、抢占都可。
- 时间片轮转调度（RR）：在就绪队列（FCFS）中设置时间片，当队首任务在时间片用完时还未结束则重新排到队尾。T(响应时间)=N(就绪进程数量)*q(时间片)
- 多级队列调度：可分为实时、系统、交互式、批处理等多个队列，每个队列有自己的调度算法，各队列间采用抢占式优先级算法，即高级队列可以抢占低级队列。
- 多级反馈队列调度：多级队列+可降级。在高级队列中，一个进程在q内还未运行完（若为阻塞情况则在恢复后插入原队列中），则插入低一级队列末尾，最后一个队列中采用RR，不再降级。

**Linux调度算法解析**

1. Linux2.4，基于优先级调度器。实时进程-静态优先级-FIFO或RR，普通进程-动态优先级。
2. Linux2.6，O(1)调度，active数组&expire数组，Prio=max(100,min(139,static_prio - bonus))
3. Linux2.6.23，CFS



## 3.6 进程通信

#### 进程通讯类型

结合OS实验3一起学习，注意进程间通讯通常要辅以信号量来完成同步/互斥操作。

- 共享存储器系统通信
  - 共享内存。进程地址空间(共享内存映射区-虚拟地址)—页面映射—>内核共享存储区(共享存储分区-物理地址)。
- 消息传递系统通信
  - 消息队列。消息队列（消息缓冲区结构体1(消息类型，消息文本，其他信息)，消息缓冲区结构体2( ),……）
- 管道通信
  - 无名管道：半双工，FIFO，非文件，存在cache中，只用于有亲缘关系的进程，pipe()系统调用建立，文件描述符。
  - 有名管道：文件，以FIFO文件存在磁盘上，可以被访问，mkfifo()系统调用建立，用open()调用。
- 客户-服务器系统通信



## 3.7 进程死锁

#### 银行家算法

- 变量
  - 进程个数n，资源个数m
  - n*m矩阵：Max-每个进程对于每个资源的最大需求量，Allocation-已分配量，Need-需求量（=Max-Allocation）
  - 1*m矩阵：Available - 当前资源的剩余量
  - Work（n*m矩阵）- 当前每个进程已分配到的资源量
  - Finish（n*1矩阵，布尔型）- 判断当前进程能否完成
- 算法
  - 安全性算法：Need[i]<=Available，资源够用 -> 该进程可以完成，(等进程运行完毕)资源全部回收，Finish[i]=true, Available+Allocation[i]。若所有进程最后都能完成，则系统是安全的。
  - 银行家算法：①进程请求资源，先判断对于其自身状态是否合法，Request[i]<=Need[i]则合法；②再判断现有资源能否满足，Request[i]<=Available则可满足；③模拟分配后的结果，进行安全性检查，若系统仍安全则正式分配。



#### 死锁检测

简化**资源分配图**：逐个找到对既不阻塞又不独立的点，消除器所有资源请求边和分配边。若最后能够完全变为独立结点，则进程不会发生死锁。

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmnbe1uo11j30ys0u0gps.jpg" style="zoom:67%;" />

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmnbdn0qv6j31120cndhn.jpg" style="zoom:80%;" />

基于银行家算法数据结构的**死锁检测算法**：对于初始Allocation为0的进程，直接将其Finish置为true，剩余通过检查其安全性，若最终所有进程都可以完成则表示不会有死锁。



## 3.8 线程机制

- 线程是**隶属于**进程的一个实体，是比进程更小的运行单位。
- 与进程的比较
  - **调度：线程是调度和执行的基本单位，进程是资源分配和拥有的基本单位。**
  - 并发性：多个线程间也能并发执行，并发度提高。
  - 拥有资源：线程基本上不拥有资源，但可以访问所属进程的数据空间。
  - 系统开销：创建线程只需建立堆栈和TCB。



# 4. 存储器管理

## 4.1 存储器管理概述

- **地址映射**（地址重定位）：为了能够正确地访问内存，必须将程序中使用的虚地址转换为（映射到）实际的物理地址。
  - 绝对装入：编译时确定映射关系
  - 静态重定位装入：装入工作完成时确定映射关系
  - 动态重定位装入：装入后目标模块中仍采用虚地址



## 4.2-4.5 存储管理方式

#### 连续

为一整个进程程序分配**【连续的一段】**物理内存空间，包括「固定分区」（分区大小固定）和「可变分区」（分区大小不固定）两种方式。

可变分区的三种**分配算法**

- 首次适应：找第一个空闲空间足够整个进程大小的
- 最佳适应：找大小和整个进程大小最接近的
- 最坏适应：找大小和整个进程大小最远的（即找最大的），减少碎片

**回收算法**：上邻接、下邻接、上下邻接、无邻接

#### 分页式

面向物理划分。将物理空间和逻辑空间划分为大小相等的块（512B~8KB）。物理空间中的块：**物理块/页框/帧**，逻辑空间中的块：**页面**。**页表**的每一个表项PTE=页号P+物理块号F，**存储在内存中**。

**分页逻辑地址结构：页号P+页内地址d（即偏移量）**。寻找物理块号的算法：**f(P)+d**，其中f(·)表示页号->物理块号的映射关系，+d表示块内偏移。由于分页式在逻辑地址上是一维线性，故可以根据相对地址计算出页号和页内地址，然后分别对应得到物理地址；此外还可以额外添加进一个**存储在Cache**中的快表，若页表命中则不需要再额外访问内存：

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu5fdfbw9j31120lkado.jpg" style="zoom:80%;" />

此外，对于大文件可以采用多级分页。逻辑地址：页目录号（总位数-页号位数-页内位数）+页号（页面大小/表项大小后得到的位数）+页内偏移量（页面大小位数）

#### 分段式

面向逻辑划分。根据程序的功能划分模块。逻辑空间中的块：**段**，每一段中使用相对地址（offset），需要根据段号、段内地址才能确定存储位置。

**分段逻辑地址结构：段号S+段内地址d（offset）**。在逻辑空间上是二维非线性的（因为其段之间的逻辑不相干性）。**段表**表项=段号+段长+段基址，**存储在内存中**。

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu5fo9kdaj31120n4n0c.jpg" style="zoom:80%;" />



#### 段页式

分页+分段。既有分页式物理上划分的方便，也有分段式逻辑上划分的优越性。

**段页式逻辑地址结构=段号S+段内页号P+页内地址d**。

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu5qq2m5bj31120jjact.jpg" style="zoom:80%;" />



## 4.6 虚拟存储系统

为了缓解存储器紧缺的问题，利用**外存**的空余空间“从逻辑上”对内存进行**扩容**。当前主流采用**分页式管理**实现虚拟存储。

- 页表：页号+物理块号+状态位P（说明该页面是否在内存中，若CPU根据当前指令得到的地址中，状态位表示不该页面不在内存中，则产生**缺页中断**，请求调页）+访问字段A（被访问情况）+修改位M（是否被修改过）+外存地址
- 若产生缺页中断，则根据**页面置换算法**进行调页
- 页面置换策略：**可变全局、可变局部、固定局部**
  - 可变/固定：进程可使用的内存物理块数量
  - 全局/局部：从内存中所有页面中选择/从进程自身已占用的页面中选择
- 页面置换算法
  - 最佳置换（OPT）：纯理论。向后找，将来永远不会再访问或最长时间内不会访问的页面
  - 先进先出（FIFO）：淘汰最先调入内存的页面。会出现**Belady现象**，当物理块数增大时缺页率可能反而会增加。
  - 最近最久未使用（LRU）：向前找，已有物理块中最久前调入的淘汰。
  - 最近最少使用（LFU）：向前找，使用次数总和最少的。
  - 时钟（CLOCK，或称最近未用NRU）：对于所有页面，定时将其“使用状态”清为0，若在该周期内某一页面被访问，则将状态置1。每次周期淘汰掉循环队列中第一个状态是0的页面。
  - 页面缓冲思想：不立即淘汰，让其在内存中“暂时缓冲”。





# 5. 设备管理

## 5.1 输入输出系统

- 设备分类：按传速率、按**信息交换单位**（块设备-磁盘等，字符设备-打印机等）、按共享属性、按工作特性。
- 设备控制器：接受识别命令、数据交换、地址识别、数据缓冲、识别状态、差错控制
- I/O系统结构：总线型、通道型



## 5.2 输入输出控制

- 程序直接控制：循环测试。CPU与设备完全串行工作，降低利用率。
- 中断驱动控制-字符设备用：CPU向I/O控制器发送I/O指令后立即返回，得到中断信号后相应中断，进行处理
- 直接存储器存取（DMA）-块设备用：DMA控制器（数据、地址、字节、命令寄存器），同样通过中断与CPU沟通，根据CPU在控制器中的设置，一块一块传
- 通道控制：组织通道程序，CPU干预更少



## 5.3 缓冲管理

- 单缓冲

  【I/O设备】—（输入T）—>【缓冲区】—（传送M）—>【内存区】（处理C）

  T和C可以并行，故处理一次的周期为Max(C,T)+M≈Max(C,T)   //通常M远小于T或C

- 双缓冲

  【I/O设备】—（输入T）—>【缓冲区1】/【缓冲区2】—（传送M）—>【内存区】（处理C）

  T和C可以并行，故处理一次的周期为Max(C+M,T)或Max(T+M,C)，约为Max(C,T)



## 5.4 I/O软件

**设备驱动程序**承上启下的流程：

1. 将抽象要求转换为具体要求
2. 对服务请求进行校验
3. 检查设备的状态
4. 传送必要的参数
5. 启动I/O设备



## 5.5 设备分配

系统设备表（SDT）—>控制表（DCT）,检查设备状态/安全性—>控制器控制表（COCT）,检查控制器状态—>通道控制表（CHCT）,检查通道状态。



## 5.6 SPOOLing系统

- 将独占设备“改造”成共享设备，使其“逻辑上”仍是独占的，但提高了设备的利用率。由于是对脱机输入输出技术的模拟，故又称为假脱机技术。
- 组成：输入井、输出井、预输入程序、缓输出程序、井管理程序
- eg. 共享打印机



# 6. 文件系统

## 6.1 概述

- 文件系统功能：文件存储空间的管理、目录管理、文件地址映射、文件读写管理、文件共享和保护。
- 文件操作：创建、删除、打开、关闭、读、写、设置读写指针、获取属性、设置属性、重命名、锁定。



## 6.2 文件的结构和存取

#### 逻辑结构

- 有结构文件
  - 顺序文件：串结构-顺序与key无关，顺序结构-顺序按key排序。
  - 索引文件：额外设置索引表，对应到逻辑文件，表可能会很大。
  - 索引顺序文件：分组，缩小索引表中的组数，组内顺序。
  - 直接文件/散列文件：利用hash等方法直接将关键字映射到物理地址。
- 无结构文件

#### 物理结构

- **连续文件**

  **文件目录项=文件名+长度+起始盘块号。**

  **一维数组**顺序存储，易产生碎片，访问O(1)，修改复杂度高。

- **链接文件**

  链表存储，可以链接离散空间，访问O(n)，修改复杂度也很高。

  - **隐式**链接：文件目录项=文件名+**起始盘块号（当前盘块号+nxt指针）**+长度，最后一块盘块的nxt==-1。文件鲁棒性较差，容易造成信息丢失。

  - **显式**链接：为每个文件系统（一个磁盘分区）额外设置一张**FAT表**（当前盘块-下一盘块，故磁盘分区有几个盘块，FAT表就有几个表项），放在外存里，使用时需要将其**全部读入内存**。文件目录项=文件名+**起始盘块号（当前盘块号）**+长度，根据其实盘块号，在FAT表中找到起始盘块及其对应的下一盘块。

    **细节注意**：FAT表项长度通常为半个字节的整数倍（4k位），如DOS系统使用FAT16,win95、98使用FAT32。

- **索引文件**

  为文件额外设置索引表（额外使用磁盘块中），根据索引表的级数分为三种。

  - **单级**索引：目录项=文件名+**索引指针**。整块磁盘块用于存放索引表（0-F1, 1-F2,……），一个磁盘块可存放的个数固定（磁盘块大小/表项大小），故会造成小文件浪费、大文件放不下。
  - **多级**索引：对于大文件，增加索引的级数，实现指数级扩容。对小文件来说造成浪费。
  - **混合**索引：同时满足小文件、大文件。下图以Unix system V文件系统为例：

  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu91qf1p0j31080u00x7.jpg" style="zoom:80%;" />

#### 存取

根据文件的存储介质类型、物理组织结构，选取复杂度尽量小、最适合文件的存取方法：

| 存储介质类型 | 磁盘       |          |            | 磁带     |
| ------------ | ---------- | -------- | ---------- | -------- |
| 物理结构     | 连续文件   | 链接文件 | 索引文件   | 连续文件 |
| 存取方法     | 顺序、随机 | 顺序     | 顺序、随机 | 顺序     |



## 6.3 文件目录管理

#### 文件目录概念

**文件控制块（FCB）**用于描述和控制文件，保存系统管理文件所需的全部属性信息。FCB设计因文件系统不同而不同，但通常包含：

- 基本信息：文件名、用户名、文件类型、物理地址、长度、逻辑结构、物理结构
- 存取控制信息：控制权限等
- 使用信息：创建时间、上次存取时间、当前使用状态等

**索引节点**的引入：FCB=文件名+索引节点（i节点）。将除文件名意外所有信息保存到另一结构体中，并用索引指针进行连接，从而减小一个FCB的大小，使得一个盘块中能放下更多的FCB，减少磁盘启动次数，提高检索效率。

分类：磁盘索引结点、内存索引节点。

#### 文件目录结构

- **单级**目录结构

  - 目录项=文件名+其他信息+物理地址。
  - 速度慢（文件多）、单用户（以文件名为key，不允许重名）

  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu9olrks6j31120fxn02.jpg" style="zoom:67%;" />

- **两级**目录结构

  - **主文件目录**（用户名+用户文件目录ptr）+**用户文件目录**（文件名+其他描述信息+物理地址）
  - 提高检索速度（根据用户名筛选掉部分文件）、多用户场景
  - 每个用户文件目录大小固定，无法满足文件量大的用户的需求

  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu9oex66ej31120izdj4.jpg" style="zoom:67%;" />

- **多级**目录结构

  - 树形结构，当前大部分操作系统所使用的结构：/A/B/C则对应树中结点连接A->B->C
  - 层次清楚、解决重名问题、便于实现文件共享、查询更快。

  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu9obcspkj31120poad7.jpg" style="zoom:67%;" />

#### 文件检索技术

- 线性检索：根据路径名和文件目录结构进行
- Hash：直接映射



## 6.4 文件空间分配&回收

即文件创建时进行空间分配、文件删除时进行空间回收。对空闲的盘块有以下几种表示法：

**（1）空闲表法**

表项=第一空闲盘块号+空闲盘块号数。

仅当空闲区数量较少时才有较好的效果。

**（2）空闲块链表法**

空闲块首指针——>F1——>F2——>……——>Fn——>NULL。有时为了进一步提高效率，将空闲盘块组合为几个空闲盘区，再进行串连，成为空闲盘区链。

**该方法适用于首次适应算法**：顺序查找，符合条件即停止。

**（3）位示图**

对于每一盘块用一个比特位来表示，1表示已占用，0表示还未被占用。将结果组合为n*m的二维数组：

<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmu9vr7qqnj31120cftam.jpg" style="zoom:80%;" />

**（4）成组链接法**

- 适用于大型文件系统

- 将空闲磁盘按照固定数量而分为若干组，优先满足序号大的进行组合。每一组中的最后一个磁盘块（组长块）专门用于记录下一组的总块数和所有盘块号，第一组额外使用一个“超级块进行记录”，最后一组的组长块设为“0”，用于特判。

- 通过「空闲盘块栈」存放当前组的所有信息（组长块中存放的信息），实现分配、回收算法，用S_Free指针存放当前可分配的盘块的地址。

- 分配算法：count用于记录当前组还剩的块数

  - count>1：分配
  - count==1：
    - S_Free==0，表示最后一组用光，拒绝分配，报错
    - else：当前组用光，换为下一组。将S_Free中的内容读入栈，count=当前组总块数，S_Free=count。

- 回收算法：n表示一个组的上限块数，回收块号

  - count<n: count++，*S_Free=b，S_Free++
  - count==n：将栈中内容写入b。count=1，S_Free=0，*S_Free=b，S_Free++。

  

## 6.5 文件共享和保护

#### 文件共享

- 基于**索引节点**

  - 通过将索引节点指向共享文件所在的索引节点，实现利用物理上的直接连接。
  - 可以通过加入一项count来表示有多少用户正在使用该文件，避免count>1时删除从而造成虚空指针。
  - 不同文件卷中的索引节点编号重复，故不能实现跨文件卷的共享。

  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmuad5k2axj31120lhwi5.jpg" style="zoom:80%;" />

- 利用**符号链接**

  - 对于需要共享其他文件的文件，将其索引节点中的文件类型设为“LINK”，并保存目标文件的路径名（以文件形式存储，而非指针，不会形成悬空指针）。

  - 开销大

    <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmuad2xxk0j31120r7djr.jpg" style="zoom:70%;" />



#### 文件保护

- 文件备份
  - 批量：全量转储（全部文件定期备份）、增量转储（近期修改过、新建立的文件定期备份）
  - 同步：镜像盘支持（磁盘镜像）、双机动态文件备份（机器镜像）
- 文件访问保护
  - 口令保护：简单密码
  - 加密保护：加密编码、密钥
  - 设置文件访问权限：文件主、用户组、其他用户，分别设立r、w、e（读写执行）权限。使用访问控制表（以资源为key）、用户权限表（以用户为key）来存放。



## 6.6 磁盘调度

#### 硬件规定

- 磁道：同心圆  / 扇区：磁道上的分区（512B）
- 磁盘容量=磁头数（磁盘个数）\*柱面数（磁道数）\*扇区数*每个扇区的字节数
- 磁盘访问时间
  - 寻道时间（找磁道）：Ts=m*n+s。n:移动的磁道数，m:相邻磁道间移动所需的时间，s:磁臂启动时间
  - 旋转延迟时间（找扇区）：取平均，Tr=(1/r)/2=1/2r。r:磁盘的旋转速度
  - 传输时间（读写时间）：Tt=b/(rN)=(b/N)/r。b:总字节数，N:每个磁道可记录的最多字节数。



#### 磁盘调度算法

找磁道——>找扇区

【移臂调度】磁道间调度——柱面号

- 先来先服务（FCFS）
- 最短寻道优先（SSTF）
- 扫描（SCAN）/电梯算法：第一个找距离最近的，然后来回扫描。
- 循环扫描（CSCAN）：第一个找距离最近的，返回时找到另一个极端
- N-Step-SCAN：分为N个子队列，队列间FCFS，队列内SCAN
- FSCAN：2-Step-SCAN（即N-Step-SCAN算法中取N=2，固定分为两个子队列，其他一致）

【旋转调度】扇区间调度——块号

